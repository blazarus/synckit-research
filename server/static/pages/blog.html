<!DOCTYPE html>
<html>
<head>
<link href="../stylesheets/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../javascripts/jquery-1.3.2.min.js"></script>
<script type="text/javascript" src="../javascripts/oni-apollo.js"></script>
<script type="text/javascript" src="../javascripts/stringify.js"></script>
<script type="text/sjs">
_skProto = function() {

    // Error Check -- Make sure 'new' keyword was used
    // ----------------------------------------------------------------
    if ( !(this instanceof _skProto) ) 
       return new _skProto();

    var _me = this;

    // Member Variables
    // ----------------------------------------------------------------
    _me._localdb = null;
    _me._timers = null;

    _me._bulkloadTime = 0;
    _me._dataTransferTime = 0;
    _me._templateTime = 0;
    _me._queryParams = {};
    
    // Methods
    // ----------------------------------------------------------------
    
    _me.opendb = function(name) {
        if (_me._localdb !== null) {
            _me._localdb.open(name);
        }
        else {
            console.error("Local DB is null.");
        }
    };

    _me.timeStart = function(obj) {
        _me._timers[obj] = (new Date).getTime();
    };
    
    _me.timeEnd = function(obj) {
        if (_me._timers[obj]) {
            var diff = (new Date).getTime() - _me._timers[obj];
            _me._timers[obj] = null;            
            return diff;
        }
        return null;
    };
    
    _me.table_exists = function(table) {
        var result = db.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?;", [table]);
        var retval = _me.hasResult(result);
        return retval;
    };
    
    _me.create_tables = function() {
        console.info("Creating Stats Table");
        if (_me._localdb !== null) {
            _me.execute("CREATE TABLE IF NOT EXISTS sk_endpoints (id integer PRIMARY KEY AUTOINCREMENT, endpoint_uri varchar(512), UNIQUE (endpoint_uri));");
            _me.execute("CREATE TABLE IF NOT EXISTS sk_views (endpoint_id integer REFERENCES sk_endpoints(id), name varchar(128), schema text, syncspec text, vshash varchar(32), UNIQUE (endpoint_id, name));");
        } else {
            console.error("Could not create stats table. Local DB is null.");
        }        
    };
    
    _me.reset = function() {
        console.info("Resetting DB");
        if (_me._localdb !== null) {
            var result = _me.execute("SELECT name FROM sqlite_master WHERE type='table';");
            if (_me.hasResult(result)) {
                for (var i = 0; i < result.length; i++) {
                    var table_name = result.item(i)['name'];
                    console.log("Dropping table: " + table_name);
                    _me.execute("DROP TABLE IF EXISTS " + table_name + ";");
                }
            }

            _me.openwebdb("synckit", "synckit local DB");
            _me.create_tables();
        }
        else {
            console.error("Local DB is null.");
        }
    };

    /* When _me function completes, the given endpoint will update the
     * sk_endpoints and sk_views tables to contain the most up-to-date
     * information on the view with name viewname and viewspec.  If the old
     * view is out of date (the view's stored vshash is not the one in the
     * viewspec), the table will be updated with the new viewspec
     * information, the old view will be dropped, and a new view will be
     * created in its stead. */
    _me.build_view = function(endpoint, viewname, viewspec) {
        var endpoint_id = _me.get_or_create_endpoint_id(endpoint);
        var view_res = _me.execute("SELECT vshash FROM sk_views WHERE endpoint_id = ? and name = ?;", [endpoint_id, viewname]);
        if (!_me.hasResult(view_res)) {
            // if it doesn't exist, create it.
            // create an entry in sk_views
            _me.execute("INSERT INTO sk_views (endpoint_id, name, schema, syncspec, vshash) VALUES (?, ?, ?, ?, ?);", [endpoint_id, viewname, JSON.stringify(viewspec.schema), JSON.stringify(viewspec.syncspec), viewspec.vshash]);
            // create a table for the view
            _me.create_view_table(_me.view_table_name(endpoint_id, viewname), viewspec.schema, viewspec.syncspec)
        } else if (viewspec.vshash != view_res.item(0)['vshash']) {
            // if it exists, but had an outdated id, re-create it
            // update the entry in sk_views
            _me.execute("UPDATE sk_views SET schema = ?, syncspec = ?, vshash = ? WHERE endpoint_id = ? AND name = ?;", [JSON.stringify(viewspec.schema), JSON.stringify(viewspec.syncspec), viewspec.vshash, endpoint_id, viewname]);
            var view_table_name = _me.view_table_name(endpoint_id, viewname);
            // drop the old view's table
            _me.execute("DROP TABLE IF EXISTS " + view_table_name + ";");
            // create the new view's table
            _me.create_view_table(view_table_name, viewspec.schema, viewspec.syncspec)
        }
    };

    /* Returns the ID of the endpoint uri, creating an entry if one doesn't
     * exist.*/
    _me.get_or_create_endpoint_id = function(endpoint) {
        endpoint_res = _me.execute("SELECT id FROM sk_endpoints WHERE endpoint_uri = ?;", [endpoint]);
        endpoint_id = 0;
        if (!_me.hasResult(endpoint_res)) {
            _me.execute("INSERT INTO sk_endpoints (endpoint_uri) VALUES (?);", [endpoint]);
            endpoint_res = _me.execute("SELECT id FROM sk_endpoints WHERE endpoint_uri = ?;", [endpoint]);
        }
        var retval = endpoint_res.item(0)['id'];
        return retval;
    };

    /* Returns the name of the view (table) in the database for the view
     * named viewname in the endpoint specified */
    _me.view_table_name = function(endpoint_id, viewname) {
        return "sk_" + viewname + endpoint_id;
    };
   
    /* Returns view information for the view at endpoint with
     * id=endpoint_id, and name specified by viewname.  fields is an array
     * of fields to be returned in a dictionary.  Possibilities are:
     * "syncspec" "vshash and "schema". 
     * NOTE: SQL Injection Hack possible if 'fields' contains illegal field
     * names.  Make sure to only call with safe field names.*/
    _me.get_view_info = function(endpoint_id, viewname, fields) {
        var sql = "SELECT ";
        for (var fieldnum in fields) {
            sql += fields[fieldnum] + ",";
        }
        sql = sql.substr(0, sql.length - 1);
        sql += " FROM sk_views WHERE endpoint_id = ? AND name = ?;";
        var res = _me.execute(sql, [endpoint_id, viewname]);
        var ret = {}
        if (_me.hasResult(res)) {
            for (var fieldnum in fields) {
                var field_data = res.item(0)[fields[fieldnum]];
                var field = fields[fieldnum];
                if (field == "syncspec" || field == "schema") {
                    field_data = JSON.parse(field_data);
                }
                ret[field] = field_data;
            }
        } else {
            console.log('Could not find view in get_view_info: ' + viewname);
        }
        return ret;
    };
    
    /* Build the view table and any necessary indices on the table
     * depending on the type of syncspec specified. 
     * NOTE/potential sql injection attack: because we can't use prepared 
     * statements for CREATE TABLE statements, be careful what table/field 
     * names you pass into this function.*/
    _me.create_view_table = function(view_table_name, schema, syncspec) {
        console.log("creating view table in local db:", view_table_name);
        var sql = "CREATE TABLE " + view_table_name + " ("; 
        for (var i = 0; i < schema.length; i++) {
            sql += schema[i] + ",";
        }
        sql = sql.substr(0, sql.length - 1);
        if (syncspec.__type === "queue") {
            sql += ", UNIQUE (" + syncspec.sortfield + ")";
        } else if (syncspec.__type === "set") {
            sql += ", UNIQUE (" + syncspec.idfield + ")";
        }
        // TODO: do we need to index cube fields?
        sql += ");";
        _me.execute(sql);
    };
    
    /* Synchronizes the local database with endpoint_uri.
     *   views_to_sync is a list of the view names of the views you wish to sync.
     *   extra_view_params is a dictionary of the form
     *       { "viewname1": {param1: val1, param2: val2},
     *         "viewname2": {param3: val3} }
     *     these parameters will be added to the query for each view.
     *     they are useful for things like sets, which must append 
     *     the ID of the item being queried (e.g., {"setname": {"filter": 30}})
     *   extra_query_params is a flat dictionary which contains arguments
     *     that will be appended to the query dictionary and apply
     *     query-wide.  arguments such as "__latency" and "__bandwidth"
     *     should be added to this dictionary. */
    _me.sync = function(endpoint_uri, views_to_sync, extra_view_params, extra_query_params, callback) {
        var endpoint_id = _me.get_or_create_endpoint_id(endpoint_uri);
        var query = _me.generate_query(endpoint_id, views_to_sync, extra_view_params);
        _me.issue_query(endpoint_uri, endpoint_id, query, extra_query_params, callback);
    };

    /* Returns the state of each of the views for a given endpoint.  _me
     * can be sent to the server to receive an updated state.  endpoint_id
     * represents the URI of the endpoint being queried. views_to_sync and
     * extra_view_params are documented in _me.sync. */
    _me.generate_query = function(endpoint_id, views_to_sync, extra_view_params) {
        if (_me._localdb !== null) {
            var query = {};
            // loop through the views we wish to sync.
            for (var viewnum in views_to_sync) {
                var viewname = views_to_sync[viewnum];
                var view_info = _me.get_view_info(endpoint_id, viewname, ['syncspec', 'vshash']);
                var syncspec = view_info.syncspec
                var vshash = view_info.vshash
                if (syncspec.__type == "set") {
                    _me.set_query(endpoint_id, viewname, syncspec, extra_view_params[viewname], query);
                }
                else if (syncspec.__type == "queue") {
                    _me.queue_query(endpoint_id, viewname, syncspec, extra_view_params[viewname], query);
                }
                else if (syncspec.__type == "cube") {
                    _me.cube_query(endpoint_id, viewname, syncspec, extra_view_params[viewname], query);
                }

                if (viewname in query) {
                    query[viewname].__vshash = vshash;
                }
            }
            return query;
        }
        else {
            console.error("Local DB is null. No Stats available");
            return {};
        }        
    };

    /* Configures the 'query' dictionary to append a query for the endpoint
     * and view specified by viewname, whose type is a set.  The syncspec
     * contains sync information for this set, and extra_params may be
     * empty, or contain a 'filter' argument, which specifies which id to
     * ask for specifically.  'query' will only be updated if there is no
     * 'filter' parameter, or if the id specified by the 'filter' parameter
     * does not exist in the current view. */
    _me.set_query = function(endpoint_id, viewname, syncspec, extra_params, query) {
        if (syncspec.__type != "set") {
            console.log("Configuring a set that isn't: " + view_name);
            return;
        }
        var send_query = true;
        var sq = {};
        var table = _me.view_table_name(endpoint_id, viewname);

        // Do we want to filter only a specific row?
        if (extra_params && ('filter' in extra_params)) {
            var theid = extra_params.filter;
            var sql = "SELECT " + syncspec.idfield + " FROM " + table;
            sql += " WHERE " + syncspec.idfield + "=?;";
            var res = _me.execute(sql, [theid]);
            // If the row doesn't already exist, we continue with the query.
            // Otherwise, we've got the row, and don't send the query.
            if (! _me.hasResult(res)) {
                sq.filter = [theid];
            } else {
                send_query = false;
            }
        }

        // send_query is true if there was no filter, or if the filtered id
        // wasn't found.
        if (send_query) {
            // generate a list of ids we already have and add those to the
            // query.
            var sql = "SELECT " + syncspec.idfield + " FROM " + table + ";";
            var res = _me.execute(sql);
            var already = [];
            if (_me.hasResult(res)) {
                for (var i = 0; i < res.length; i++) {
                    already.push(res[0]);
                }
            }
            if (already.length > 0) {
                sq.exclude = already;	
            }
            query[viewname] = sq;
        }
    };

    /* Configures the 'query' dictionary to append a query for the endpoint
     * and view specified by viewname, whose type is a queue.  The syncspec
     * contains sync information for this queue, and extra_params may be
     * empty, or contain a 'now' argument, which is only used for
     * testing.  'now' can be set to the date at which to display the
     * queue, to facilitate time-travel: no row with sortfield greater than
     * the 'now' value will be displayed. */
    _me.queue_query = function(endpoint_id, viewname, syncspec, extra_params, query) {
        if (syncspec.__type != "queue") {
            console.log("Configuring a queue that isn't: " + view_name);
            return;
        }

        var sq = {};
        var minmax;
        if (syncspec.order == "DESC") {
            minmax = "min";
        }
        else if (syncspec.order == "ASC") {
            minmax = "max";
        }
        var table = _me.view_table_name(endpoint_id, viewname);
        var stmt = "SELECT " + minmax;
        stmt += "(" + syncspec.sortfield + ") FROM " + table + ";";
        var res  = _me.execute(stmt);
        if (_me.hasResult(res) && (res.item(0)[Object.keys(res.item(0))[0]] != null)) {
            sq[minmax] = res.item(0)[Object.keys(res.item(0))[0]]
        }
        if (extra_params && ('now' in extra_params)) {
            console.log("now in extra_params");
            console.log(extra_params);
            sq.now = extra_params.now;
        }
        query[viewname] = sq;
    };

    /* Configures the 'query' dictionary to append a query for the endpoint
     * and view specified by viewname, whose type is a data cube.  The syncspec
     * contains sync information for this cube.  Currently, there is no
     * special functionality of the state of the cube, so an empty query is
     * always sent for the view. */
    _me.cube_query = function(endpoint_id, viewname, syncspec, extra_params, query) {
        if (syncspec.__type != "cube") {
            console.log("Configuring a cube that isn't: " + view_name);
            return;
        }
        query[viewname] = {};
    };
    
    /* Sends the query to the endpoint after appending extra_query_params
     * to it.  Once a response comes back, _me.bulkload will be called
     * asynchronously, which will call the callback that the user specified
     * after properly syncing the local database. */
    _me.issue_query = function(endpoint_uri, endpoint_id, query, extra_query_params, callback) {
        var numViews = 0;
        for (view in query) {
            numViews++;
        }
        if (numViews > 0) {
            var params = {"queries":JSON.stringify(query)};
            for (var key in extra_query_params) {
                params[key] = extra_query_params[key];
            }
            
            _me._queryParams = params;            
            _me.timeStart("xfer");
            jQuery.post(endpoint_uri, params, function(response) {
                _me._dataTransferTime = _me.timeEnd("xfer");
                _me.bulkload(response, endpoint_id, endpoint_uri, callback);
            }, "json");
        } else {
            callback();
        }

    };
    
    /* Executes a query using HTML5 Web DB
     * statement is a string that is the prepared SQL statement
     * args are the arguments to fill in the prepared statement
     * returns a SQLResultSetRowList, which has an 'item(index)' method
     * and a 'length' field. Call item to get the row, which is just
     * a dictionary with the form row[rs.fieldName(i)] = rs.field(i);
    */
    _me.execute = function(statement, args) {
        try {
            console.log("performing query: " + statement + ", " + args);
            var result = _me._localdb.executeSql(statement, args).rows;
            console.log("query result: ", result);
            return result;
        } catch(e) {
            console.error("something went wrong: " + e);
        }
    };
    
     _me.hasResult = function(res) {
        if (res == undefined || res.length == 0) return false;
        return true;
     };

    // Returns the result of a query as a JSON statement
    _me.json_results_for = function(statement, args) {
        if (_me._localdb !== null) {
            var res = _me._localdb.execute(statement, args);
            var ans = [];
            if (_me.hasResult(res)) {
                for (var i = 0; i < res.length; i++) {
                    var obj = {};
                    for (var j=0; j<res.fieldCount(); j++) {
                        obj[res.item(i).fieldName(j)] = res.item(i).field(j);
                    }
                    ans[ans.length] = obj;
                }
            }
            return ans;      
        }
        else {
            console.error("Can't execute query. Local DB is null.");
        }
    };

    // Takes a hash table where keys are the label
    // and values are the sql statements
    _me.process_data_spec = function(data_spec) {
        var ret = {};
        for (var key in data_spec) {
            var val = data_spec[key];
            if (typeof(val) == "string") {
                ret[key] = _me.json_results_for(val);
            }
            else if (typeof(val) == "object") {
                ret[key] = _me.process_data_spec(val);
            }
        }
        return ret;
    };
    
    _me.bulkload = function(response, endpoint_id, endpoint_uri, callback) {
        _me.timeStart("bulkload");
        for (var viewname in response) {
            var viewdata = response[viewname];
            if (typeof(viewdata) == "string") {
                console.info("Skipping view " + viewname + " with message: " + viewdata);
                continue;
            }
            
            // if a viewspec comes back, the server is signalling that we
            // might have a new schema for this view.  try to rebuild the view.
            if ("viewspec" in viewdata) {
                _me.build_view(endpoint_uri, viewname, viewdata.viewspec);
            }

            // Insert the results into the view if any exist
            var results = viewdata.results;
            if (results.length == 0) {
            	continue;
            }
            var viewtable = _me.view_table_name(endpoint_id, viewname);
            var sqlStatement = "INSERT INTO " + viewtable + " VALUES (";
            for (var z = 0; z<results[0].length; z++) {
                sqlStatement += "?,";
            }   
            sqlStatement = sqlStatement.substr(0,sqlStatement.length - 1);
            sqlStatement += ");";
            
            for (var rownum in results) {
                _me.execute(sqlStatement, results[rownum]);
            }
        }
        // Alert the sync requester that the job is done.
        _me._bulkloadTime = _me.timeEnd("bulkload");
        callback();
    };

    
    // Debugging Methods
    // ----------------------------------------------------------------
    // 
     _me.dump_stats = function(table) {
        if (typeof(table) == "undefined") {
            // Get a list of all tables
            var result = _me.execute("SELECT name FROM sqlite_master WHERE type='table';");
            if (_me.hasResult(result)) {
                for (var i = 0; i < result.length; i++) {
                    console.info("===" + result.item(i)[0] + "===");
                    _me.dump_stats(result.item(i)[0]);
                    console.info("=============================");
                    console.info("=============================");
                }
            }
            return false;
        }
    };
    
    _me.dump = function(table) {
        if (typeof(table) == "undefined") {
            // Get a list of all tables
            var result = _me.execute("SELECT name FROM sqlite_master WHERE type='table';");
            if (_me.hasResult(result)) {
                for (var i = 0; i < result.length; i++) {
                    console.info("table name: " + result.item(i)['name']);
                    _me.dump(result.item(i)['name']);
                    console.info("=============================");
                    console.info("=============================");
                }
            }
            return false;
            
        }
        
        if (_me._localdb !== null) {
            var rs = _me.execute("SELECT * FROM " + table + ";");
            
            if (_me.hasResult(rs)) {
                for (var i = 0; i < rs.length; i++) {
                    console.log("Fields: " + Object.keys(rs.item(i)));
                    for (j in Object.keys(rs.item(i))) {
                        console.log(rs.item(i)[Object.keys(rs.item(i))[j]]);
                    }
                    console.log("----");
                }
            }
        }
        else {
            console.error("Can't dump. Local DB is null.");
        }
    };
    
    // Initializing web database
    // ----------------------------------------------------------------
    
    _me.openwebdb = function(db_name, db_description) {
        var dbSize = 5 * 1024 * 1024; // 5MB
        _me._localdb = require("../javascripts/webdatabase")
            .openDatabase(db_name, "1.0", db_description, dbSize);
    };
    
    _me.openwebdb("synckit", "synckit local DB");
    _me._timers = {};
    //_me.opendb("synckit"); 
    _me.create_tables();

    
}; // end _skProto = function() {

create_synckit = function() {
    var db = new _skProto();
    return db;
};

function urlParam(name){
	var results = new RegExp('[#&]' + name + '=([^&#]*)').exec(window.location.href);
	if (results) {
		return results[1].replace(/%20/,' ')
	}
	return 0;
}

</script>
<script type="text/sjs">

jQuery.fn.template = function(value) {
	if (value === undefined) {
    	return this.data("backstage_template");        
    }
    else {
        this.data("backstage_template", value);
        return this;
    }
};

jQuery.fn.templateData = function(value) {
	if (value === undefined) {
    	return this.data("backstage_templateData");        
    }
    else {
        this.data("backstage_templateData", value);
        return this;
    }
};

jQuery.fn.render_new = function(callback) {
	window.synckit.timeStart("Rendering SQL Template");
	var query = this.attr('query');
	var templates = this.find("[itemscope]");
	var res = window.synckit.execute(query);
	console.log("Rendering template with query result: ", res);
	var map = {};
	
	if (window.synckit.hasResult(res)) {
        for (var x = 0; x < res.length; x++) {
            // Loop over each item to do
            templates.each(function(i) {
                jQuery(this).find("[itemprop]").each(function(j) {
                    var prop = jQuery(this).attr("itemprop");
                    var val = res.item(x)[prop];
                    jQuery(this).html(val);
                });
                jQuery(this).before(jQuery(this).clone());
            });
        }
    }

	templates.each(function(i) {
		jQuery(this).remove();
	});

	window.synckit.timeEnd("Rendering SQL Template");
	if (callback !== undefined) {
		callback.call();
	}
}

jQuery.fn.render_flying = function(results) { 
    
	var templates = this.find("[itemscope]");
	var map = {};
	
	for (var i=0; i<results.length; i++) {
		// Loop over each item to do
		templates.each(function(i) {
			jQuery(this).find("[itemprop]").each(function(j) {
				var prop = jQuery(this).attr("itemprop");
				var val = results[i][replacementFieldByName(prop)];
				jQuery(this).html(val);
			});
			jQuery(this).before(jQuery(this).clone());
		});
    }

	templates.each(function(i) {
		jQuery(this).remove();
	});
}




</script>
<script type="text/sjs">
$(function() {
    // console.info("Page Loaded");
    window.synckit = create_synckit(); 
    var endpoint = "/blog/entries";

    var viewspec = {
        "vshash": "3c9977be25383449119b351ce5388e81",
        "syncspec": {
             "limit": 10,
             "__type": "queue",
             "order": "ASC",
             "sortfield": "date"
            }, 
        "schema": ["id serial", "author integer", "title varchar(200)", "contents text", "date timestamp with time zone"]
    };

    window.synckit.build_view(endpoint, "Posts", viewspec);

    // 'now' is a parameter used for time-travel through the posts
    var extra_view_params = {};
    var now = urlParam('now');
	if (now != 'undefined' && now != '0') {
	    extra_view_params.Posts = {"now": now};
	}
    
    var callback = function() {
        window.synckit.timeStart("template");
		$('#newtemplate').render_new();
	    window.synckit._templateTime = window.synckit.timeEnd("template");
        //if (parent.LogData != "undefined") {
        //	parent.LogData("Blog", "Sync Kit", window.location.href, window.synckit);
        //}
    };

    window.synckit.sync(endpoint, ["Posts"], extra_view_params, {}, callback);
});

</script>
</head>
<body>  
    
<div id="loading">
    <button id="clearButton" onclick="window.synckit.reset();">Reset DB</button><button onclick="window.synckit.dump();">Dump DB</button>
</div>

<div id="debug">
</div>
<div id="templated">
<p align="center"><b>Template Loading...</b></p>
</div>

<table id="newtemplate" query="SELECT * FROM sk_Posts1 LIMIT 10;" as="entry">
	<tr itemscope="yes" itemtype="Entry" />
		<td><span itemprop="title">from</span></td>
		<td><span itemprop="contents">content</span></td>
	</tr>
</table>

</body>

</html>
